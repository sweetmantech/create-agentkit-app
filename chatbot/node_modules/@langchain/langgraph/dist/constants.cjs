"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._isCommand = exports.Command = exports._isSend = exports.Send = exports._isSendInterface = exports.CHECKPOINT_NAMESPACE_END = exports.CHECKPOINT_NAMESPACE_SEPARATOR = exports.RESERVED = exports.NULL_TASK_ID = exports.TASK_NAMESPACE = exports.PULL = exports.PUSH = exports.TASKS = exports.TAG_NOSTREAM = exports.TAG_HIDDEN = exports.RECURSION_LIMIT_DEFAULT = exports.RUNTIME_PLACEHOLDER = exports.RESUME = exports.INTERRUPT = exports.CONFIG_KEY_CHECKPOINT_MAP = exports.CONFIG_KEY_RESUME_VALUE = exports.CONFIG_KEY_STREAM = exports.CONFIG_KEY_TASK_ID = exports.CONFIG_KEY_RESUMING = exports.CONFIG_KEY_CHECKPOINTER = exports.CONFIG_KEY_READ = exports.CONFIG_KEY_SEND = exports.ERROR = exports.INPUT = exports.MISSING = void 0;
exports.MISSING = Symbol.for("__missing__");
exports.INPUT = "__input__";
exports.ERROR = "__error__";
exports.CONFIG_KEY_SEND = "__pregel_send";
exports.CONFIG_KEY_READ = "__pregel_read";
exports.CONFIG_KEY_CHECKPOINTER = "__pregel_checkpointer";
exports.CONFIG_KEY_RESUMING = "__pregel_resuming";
exports.CONFIG_KEY_TASK_ID = "__pregel_task_id";
exports.CONFIG_KEY_STREAM = "__pregel_stream";
exports.CONFIG_KEY_RESUME_VALUE = "__pregel_resume_value";
// this one is part of public API
exports.CONFIG_KEY_CHECKPOINT_MAP = "checkpoint_map";
exports.INTERRUPT = "__interrupt__";
exports.RESUME = "__resume__";
exports.RUNTIME_PLACEHOLDER = "__pregel_runtime_placeholder__";
exports.RECURSION_LIMIT_DEFAULT = 25;
exports.TAG_HIDDEN = "langsmith:hidden";
exports.TAG_NOSTREAM = "langsmith:nostream";
exports.TASKS = "__pregel_tasks";
exports.PUSH = "__pregel_push";
exports.PULL = "__pregel_pull";
exports.TASK_NAMESPACE = "6ba7b831-9dad-11d1-80b4-00c04fd430c8";
exports.NULL_TASK_ID = "00000000-0000-0000-0000-000000000000";
exports.RESERVED = [
    exports.INTERRUPT,
    exports.RESUME,
    exports.ERROR,
    exports.TASKS,
    exports.CONFIG_KEY_SEND,
    exports.CONFIG_KEY_READ,
    exports.CONFIG_KEY_CHECKPOINTER,
    exports.CONFIG_KEY_RESUMING,
    exports.CONFIG_KEY_TASK_ID,
    exports.CONFIG_KEY_STREAM,
    exports.CONFIG_KEY_CHECKPOINT_MAP,
    exports.INPUT,
];
exports.CHECKPOINT_NAMESPACE_SEPARATOR = "|";
exports.CHECKPOINT_NAMESPACE_END = ":";
function _isSendInterface(x) {
    const operation = x;
    return typeof operation.node === "string" && operation.args !== undefined;
}
exports._isSendInterface = _isSendInterface;
/**
 *
 * A message or packet to send to a specific node in the graph.
 *
 * The `Send` class is used within a `StateGraph`'s conditional edges to
 * dynamically invoke a node with a custom state at the next step.
 *
 * Importantly, the sent state can differ from the core graph's state,
 * allowing for flexible and dynamic workflow management.
 *
 * One such example is a "map-reduce" workflow where your graph invokes
 * the same node multiple times in parallel with different states,
 * before aggregating the results back into the main graph's state.
 *
 * @example
 * ```typescript
 * import { Annotation, Send, StateGraph } from "@langchain/langgraph";
 *
 * const ChainState = Annotation.Root({
 *   subjects: Annotation<string[]>,
 *   jokes: Annotation<string[]>({
 *     reducer: (a, b) => a.concat(b),
 *   }),
 * });
 *
 * const continueToJokes = async (state: typeof ChainState.State) => {
 *   return state.subjects.map((subject) => {
 *     return new Send("generate_joke", { subjects: [subject] });
 *   });
 * };
 *
 * const graph = new StateGraph(ChainState)
 *   .addNode("generate_joke", (state) => ({
 *     jokes: [`Joke about ${state.subjects}`],
 *   }))
 *   .addConditionalEdges("__start__", continueToJokes)
 *   .addEdge("generate_joke", "__end__")
 *   .compile();
 *
 * const res = await graph.invoke({ subjects: ["cats", "dogs"] });
 * console.log(res);
 *
 * // Invoking with two subjects results in a generated joke for each
 * // { subjects: ["cats", "dogs"], jokes: [`Joke about cats`, `Joke about dogs`] }
 * ```
 */
class Send {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(node, args) {
        Object.defineProperty(this, "node", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: node
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: args
        });
        Object.defineProperty(this, "lg_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Send"
        });
    }
}
exports.Send = Send;
function _isSend(x) {
    const operation = x;
    return operation.lg_name === "Send";
}
exports._isSend = _isSend;
class Command {
    constructor(args) {
        Object.defineProperty(this, "lg_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Command"
        });
        Object.defineProperty(this, "resume", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.resume = args.resume;
    }
}
exports.Command = Command;
function _isCommand(x) {
    return typeof x === "object" && !!x && x.lg_name === "Command";
}
exports._isCommand = _isCommand;
