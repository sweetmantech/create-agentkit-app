"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStore = exports.InMemoryStore = void 0;
const base_js_1 = require("./base.cjs");
class InMemoryStore extends base_js_1.BaseStore {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    async batch(operations) {
        const results = [];
        for (const op of operations) {
            if ("key" in op && "namespace" in op && !("value" in op)) {
                // GetOperation
                results.push(this.getOperation(op));
            }
            else if ("namespacePrefix" in op) {
                // SearchOperation
                results.push(this.searchOperation(op));
            }
            else if ("value" in op) {
                // PutOperation
                results.push(this.putOperation(op));
            }
            else if ("matchConditions" in op) {
                // ListNamespacesOperation
                results.push(this.listNamespacesOperation(op));
            }
        }
        return Promise.resolve(results);
    }
    getOperation(op) {
        const namespaceKey = op.namespace.join(":");
        const item = this.data.get(namespaceKey)?.get(op.key);
        return item || null;
    }
    searchOperation(op) {
        const candidates = [];
        for (const [namespace, items] of this.data.entries()) {
            if (namespace.startsWith(op.namespacePrefix.join(":"))) {
                candidates.push(...items.values());
            }
        }
        let filteredCandidates = candidates;
        if (op.filter) {
            filteredCandidates = candidates.filter((item) => Object.entries(op.filter).every(([key, value]) => item.value[key] === value));
        }
        const searchResults = filteredCandidates.slice(op.offset || 0, (op.offset || 0) + (op.limit || 10));
        return searchResults;
    }
    putOperation(op) {
        const namespaceKey = op.namespace.join(":");
        if (!this.data.has(namespaceKey)) {
            this.data.set(namespaceKey, new Map());
        }
        const namespaceMap = this.data.get(namespaceKey);
        if (op.value === null) {
            namespaceMap.delete(op.key);
        }
        else {
            const now = new Date();
            if (namespaceMap.has(op.key)) {
                const item = namespaceMap.get(op.key);
                item.value = op.value;
                item.updatedAt = now;
            }
            else {
                namespaceMap.set(op.key, {
                    value: op.value,
                    key: op.key,
                    namespace: op.namespace,
                    createdAt: now,
                    updatedAt: now,
                });
            }
        }
    }
    listNamespacesOperation(op) {
        const allNamespaces = Array.from(this.data.keys()).map((ns) => ns.split(":"));
        let namespaces = allNamespaces;
        if (op.matchConditions && op.matchConditions.length > 0) {
            namespaces = namespaces.filter((ns) => op.matchConditions.every((condition) => this.doesMatch(condition, ns)));
        }
        if (op.maxDepth !== undefined) {
            namespaces = Array.from(new Set(namespaces.map((ns) => ns.slice(0, op.maxDepth).join(":")))).map((ns) => ns.split(":"));
        }
        namespaces.sort((a, b) => a.join(":").localeCompare(b.join(":")));
        const paginatedNamespaces = namespaces.slice(op.offset, op.offset + op.limit);
        return paginatedNamespaces;
    }
    doesMatch(matchCondition, key) {
        const { matchType, path } = matchCondition;
        if (key.length < path.length) {
            return false;
        }
        if (matchType === "prefix") {
            return path.every((pElem, index) => {
                const kElem = key[index];
                return pElem === "*" || kElem === pElem;
            });
        }
        else if (matchType === "suffix") {
            return [...path].reverse().every((pElem, index) => {
                const kElem = key[key.length - 1 - index];
                return pElem === "*" || kElem === pElem;
            });
        }
        throw new Error(`Unsupported match type: ${matchType}`);
    }
}
exports.InMemoryStore = InMemoryStore;
/** @deprecated Alias for InMemoryStore */
class MemoryStore extends InMemoryStore {
}
exports.MemoryStore = MemoryStore;
