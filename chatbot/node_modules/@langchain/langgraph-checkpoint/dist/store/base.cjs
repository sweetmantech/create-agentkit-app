"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseStore = exports.InvalidNamespaceError = void 0;
/**
 * Error thrown when an invalid namespace is provided.
 */
class InvalidNamespaceError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidNamespaceError";
    }
}
exports.InvalidNamespaceError = InvalidNamespaceError;
/**
 * Validates the provided namespace.
 * @param namespace The namespace to validate.
 * @throws {InvalidNamespaceError} If the namespace is invalid.
 */
function validateNamespace(namespace) {
    if (namespace.length === 0) {
        throw new InvalidNamespaceError("Namespace cannot be empty.");
    }
    for (const label of namespace) {
        if (typeof label !== "string") {
            throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels ` +
                `must be strings, but got ${typeof label}.`);
        }
        if (label.includes(".")) {
            throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`);
        }
        if (label === "") {
            throw new InvalidNamespaceError(`Namespace labels cannot be empty strings. Got ${label} in ${namespace}`);
        }
    }
    if (namespace[0] === "langgraph") {
        throw new InvalidNamespaceError(`Root label for namespace cannot be "langgraph". Got: ${namespace}`);
    }
}
/**
 * Abstract base class for key-value stores.
 */
class BaseStore {
    // convenience methods
    /**
     * Retrieve a single item.
     * @param namespace Hierarchical path for the item.
     * @param key Unique identifier within the namespace.
     * @returns A promise that resolves to the retrieved item or null if not found.
     */
    async get(namespace, key) {
        const batchResult = await this.batch([{ namespace, key }]);
        return batchResult[0];
    }
    /**
     * Search for items within a namespace prefix.
     * @param namespacePrefix Hierarchical path prefix to search within.
     * @param options Search options.
     * @param options.filter Key-value pairs to filter results.
     * @param options.limit Maximum number of items to return (default: 10).
     * @param options.offset Number of items to skip before returning results (default: 0).
     * @returns A promise that resolves to a list of items matching the search criteria.
     */
    async search(namespacePrefix, options) {
        const optionsWithDefaults = {
            limit: 10,
            offset: 0,
            ...(options || {}),
        };
        const batchResults = await this.batch([
            { namespacePrefix, ...optionsWithDefaults },
        ]);
        return batchResults[0];
    }
    /**
     * Store or update an item.
     * @param namespace Hierarchical path for the item.
     * @param key Unique identifier within the namespace.
     * @param value Object containing the item's data.
     */
    async put(namespace, key, value) {
        validateNamespace(namespace);
        await this.batch([{ namespace, key, value }]);
    }
    /**
     * Delete an item.
     * @param namespace Hierarchical path for the item.
     * @param key Unique identifier within the namespace.
     */
    async delete(namespace, key) {
        await this.batch([{ namespace, key, value: null }]);
    }
    /**
     * List and filter namespaces in the store.
     * @param options Options for listing namespaces.
     * @param options.prefix Filter namespaces that start with this path.
     * @param options.suffix Filter namespaces that end with this path.
     * @param options.maxDepth Return namespaces up to this depth in the hierarchy.
     * @param options.limit Maximum number of namespaces to return (default 100).
     * @param options.offset Number of namespaces to skip for pagination (default 0).
     * @returns A promise that resolves to a list of namespace arrays that match the criteria.
     */
    async listNamespaces(options) {
        const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
        const matchConditions = [];
        if (prefix) {
            matchConditions.push({ matchType: "prefix", path: prefix });
        }
        if (suffix) {
            matchConditions.push({ matchType: "suffix", path: suffix });
        }
        const op = {
            matchConditions: matchConditions.length > 0 ? matchConditions : undefined,
            maxDepth,
            limit,
            offset,
        };
        const batchResults = await this.batch([op]);
        return batchResults[0];
    }
    /**
     * Stop the store. No-op if not implemented.
     */
    stop() {
        // no-op if not implemented.
    }
    /**
     * Start the store. No-op if not implemented.
     */
    start() {
        // no-op if not implemented.
    }
}
exports.BaseStore = BaseStore;
